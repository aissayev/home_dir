function parse_git_info {
	branch=`parse_git_branch`;
	if [ -n "$branch" ];
	then
		status=`parse_git_status`;
		if [ -n "$status" ];
		then
			echo -e "\033[0;36m:\033[0;33m[$branch\033[1;37m:$status\033[0;33m]";
		else
			echo -e "\033[0;36m:\033[0;33m[$branch\033[0;33m]";
		fi
	fi
}

function parse_git_branch {
	branch=`git branch --no-color 2> /dev/null | grep '\* ' | tr -d '* '`;
	if [ -n "$branch" ];
	then
		echo -e "\033[1;30m$branch";
	fi
}

function parse_git_status {
	status=`git status 2> /dev/null`;
	accumulated_status="";
	if [[ $status =~ "Your branch is ahead" ]] || [[ `git show --oneline origin/master 2> /dev/null | head -1` != `git show --oneline 2> /dev/null | head -1` ]];
	then
		accumulated_status="$accumulated_status\033[1;32mc";
	fi
	if [[ $status =~ "Changes to be committed:" ]];
	then
		accumulated_status="$accumulated_status\033[1;36ms";
	fi
	if [[ $status =~ "Unmerged paths:" ]];
	then
		accumulated_status="$accumulated_status\033[1;34mm";
	fi
	if [[ $status =~ "Changes not staged for commit:" ]];
	then
		accumulated_status="$accumulated_status\033[1;35mu";
	fi
	if [[ $status =~ "Untracked files:" ]];
	then
		accumulated_status="$accumulated_status\033[1;31mn";
	fi
	if [ -n "$accumulated_status" ];
	then
		echo -e $accumulated_status;
	fi
}

export PS1='\[\033[1;34m\]\u\[\033[1;31m\]@\[\033[1;32m\]\h\[\033[0;36m\]:\[\033[0;35m\](\[\033[1;37m\]\w\[\033[0;35m\])$(parse_git_info)\[\033[1;33m\]\$ \[\033[0m\]'
