# Change to the containing directory if the first argument was a file
cd () {
  last_directory=$PWD;

  if [ $# -eq 1 ] && [ -f $1 ]; then
    builtin cd $(dirname $1);
  else
    builtin cd "$@";
  fi

  if [ "$last_directory" = "$PWD" ]; then
    return;
  fi

  noautoworkon_file=$HOME/.noautoworkon;
  if [ -f $noautoworkon_file ]; then
    return;
  fi

  if \
    [ -e $PWD/.node-version ] ||
    [ -e $PWD/.notags ] ||
    [ -e $PWD/.python-version ] ||
    [ -e $PWD/.ruby-version ] ||
    [ -e $PWD/.workonrc ];
then
    source $HOME/bin/workon.sh .;
  elif [ -n "$PROJECT_DIRECTORY" ] && [[ ! $PWD =~ ^$PROJECT_DIRECTORY ]]; then
    deactivate_environment;
  fi
}

# Deactivate the active environment
deactivate_environment () {
  unset NOTAGS;
  unset PROJECT_DIRECTORY;

  unset NODE_VERSION;
  unset PYTHON_VERSION;
  unset RUBY_VERSION;

  if [ -n "$MEMOIZED_PATH" ]; then
    export PATH=$MEMOIZED_PATH;
  fi
}

# Echos an asterix if the local [git] repo has changes
parse_git_dirty () {
  nogitdirty_file=$HOME/.nogitdirty;
  if [ -f $nogitdirty_file ]; then
    return;
  fi

  dirty=`git status --porcelain 2> /dev/null`;
  if [ -n "$dirty" ]; then
    echo "*";
  fi
}

# Echos the current [git] branch
parse_git_branch () {
  nogitbranch_file=$HOME/.nogitbranch;
  if [ -f $nogitbranch_file ]; then
    return;
  fi

  branch=`git rev-parse --abbrev-ref HEAD 2> /dev/null`;
  if [ -n "$branch" ]; then
    echo "${branch}";
  fi
}

# Echos the current environment info
environment_prompt_info () {
  noenvironmentinfo_file=$HOME/.noenvironmentinfo;
  if [ -f $noenvironmentinfo_file ]; then
    return;
  fi

  active_versions="";

  if [ -n "$NODE_VERSION" ]; then
    active_versions="$active_versions $NODE_VERSION";
  fi

  if [ -n "$PYTHON_VERSION" ]; then
    active_versions="$active_versions $PYTHON_VERSION";
  fi

  if [ -n "$RUBY_VERSION" ]; then
    active_versions="$active_versions $RUBY_VERSION";
  fi

  if [ -n "$active_versions" ]; then
    echo "($(echo $active_versions | sed 's/(^ *| *$)//g' | sed 's/ /, /g')) ";
  fi
}

# Echos an "x" if the previous command has a non-zero exit-code
error_prompt_info () {
  last_exit_code=$?;

  noerrorinfo_file=$HOME/.noerrorinfo;
  if [ -f $noerrorinfo_file ]; then
    return;
  fi

  if [ $last_exit_code -ne 0 ]; then
    echo "x ";
  fi
}

# Echos the combination of git-branch and git-dirty to form an informative prompt
git_prompt_info () {
  nogitinfo_file=$HOME/.nogitinfo;
  if [ -f $nogitinfo_file ]; then
    return;
  fi

  if ! \which git > /dev/null 2>&1; then
    return;
  fi

  branch=$(parse_git_branch);
  dirty=$(parse_git_dirty);

  if [ -n "$branch" ] || [ -n "$dirty" ]; then
    echo "${branch}${dirty} ";
  fi
}
