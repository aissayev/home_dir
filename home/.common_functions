# Change to the containing directory if the first argument was a file
cd () {
  last_directory=$PWD;

  if [ $# -eq 1 ] && [ -f $1 ]; then
    builtin cd $(dirname $1);
  else
    builtin cd "$@";
  fi

  if [ "$last_directory" = "$PWD" ]; then
    return;
  fi

  noautoworkon_file=$HOME/.noautoworkon;
  if [ -f $noautoworkon_file ]; then
    return;
  fi

  if [ -f $PWD/.workonrc ] || [ -e $PWD/.python_environment ]; then
    source $HOME/bin/workon.sh .;
  elif [ -n "$PROJECT_DIRECTORY" ] && [[ ! $PWD =~ ^$PROJECT_DIRECTORY ]]; then
    deactivate_environment;
  fi
}

# Deactivate the active environment
deactivate_environment () {
  unset PROJECT_DIRECTORY;

  unset GOPATH;
  unset GO_ENVIRONMENT;

  unset CLASSPATH;
  unset JAVA_HOME;
  unset JAVA_ENVIRONMENT;

  deactivate > /dev/null 2>&1;

  unset GEM_HOME;
  unset GEM_PATH;
  unset RUBY_ENVIRONMENT;

  if [ -n "$MEMOIZED_PATH" ]; then
    export PATH=$MEMOIZED_PATH;
  fi
}

# Echos an asterix if the local [git] repo has changes
parse_git_dirty () {
  nogitdirty_file=$HOME/.nogitdirty;
  if [ -f $nogitdirty_file ]; then
    return;
  fi

  dirty=`git status --porcelain 2> /dev/null`;
  if [ -n "$dirty" ]; then
    echo "*";
  fi
}

# Echos the current [git] branch
parse_git_branch () {
  nogitbranch_file=$HOME/.nogitbranch;
  if [ -f $nogitbranch_file ]; then
    return;
  fi

  branch=`git rev-parse --abbrev-ref HEAD 2> /dev/null`;
  if [ -n "$branch" ]; then
    echo "${branch}";
  fi
}

# Echos the current environment info
environment_prompt_info () {
  noenvironmentinfo_file=$HOME/.noenvironmentinfo;
  if [ -f $noenvironmentinfo_file ]; then
    return;
  fi

  if [ -n "$GO_ENVIRONMENT" ]; then
    echo "($(basename $GO_ENVIRONMENT)) ";
  elif [ -n "$JAVA_ENVIRONMENT" ]; then
    echo "($(basename $JAVA_ENVIRONMENT)) ";
  elif [ -n "$PYTHON_ENVIRONMENT" ]; then
    echo "($(basename $PYTHON_ENVIRONMENT)) ";
  elif [ -n "$RUBY_ENVIRONMENT" ]; then
    echo "($(basename $RUBY_ENVIRONMENT)) ";
  fi
}

# Echos an "x" if the previous command has a non-zero exit-code
error_prompt_info () {
  last_exit_code=$?;

  noerrorinfo_file=$HOME/.noerrorinfo;
  if [ -f $noerrorinfo_file ]; then
    return;
  fi

  if [ $last_exit_code -ne 0 ]; then
    echo "x ";
  fi
}

# Echos the combination of git-branch and git-dirty to form an informative prompt
git_prompt_info () {
  nogitinfo_file=$HOME/.nogitinfo;
  if [ -f $nogitinfo_file ]; then
    return;
  fi

  if ! \which git > /dev/null 2>&1; then
    return;
  fi

  branch=$(parse_git_branch);
  dirty=$(parse_git_dirty);

  if [ -n "$branch" ] || [ -n "$dirty" ]; then
    echo "${branch}${dirty} ";
  fi
}
